<!DOCTYPE html>
<html lang="en">
    <head>
        <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
        <meta content="utf-8" http-equiv="encoding">
        <title>Tetris</title>

        <!-- THIS FIRST -->
        <link rel="stylesheet" href="../../Resources/css/stylesheet.css" type="text/css"/>


        <script src="jquery-1.11.2.min.js"></script>
        <script src="pixi.js"></script>
        <script type="text/javascript" src="//code.jquery.com/jquery-1.9.1.js"></script>
        <script type="text/javascript" src="get_data.js"></script>


    </head>
    <body id="body">

    <div id="header">
        <img src="/Resources/Images/uofufootball.jpg" alt="Rice Eccles Stadium" />
        <h1>University of Utah - CS 4540</h1>
        <h2>Web Software Architecture - Spring 2016</h2>
        <h2>Brandon Tobin</h2>
        <h2>Tetris</h2>
    </div>

    <!-- Navigation Bar -->
    <ul id="navigation">
        <li><a href="../../index.html">Home</a></li>
        <li><a href="../index.html">Projects</a></li>
        <li><a href="../../Class_Examples/">Examples</a></li>
        <li><a href="../V3/schema.html">Database Schema</a></li>
        <li><a href="README.html">Tetris README</a></li>
    </ul>

    <br /><br />

    <!-- Start Button -->
    <input type="button" class="button" id="start" value="Start Game" onclick="after_load()">

    <br />

    <!-- Area for AJAx-->
    <div id="pagetop">
        <form method='post' id = "nameSubmit">
            <label for="name">Name:</label>
            <input type="text" name="name" id="name" onkeyup="score()" />
            <input type="button" class="button" name='submit' value='Submit Score' onclick="find_data()"/>
            <input type = "hidden" name="scoreValue" id = "scoreValue" value="" />
        </form>
    </div>

    <!-- Calls the score() method when the time updates -->
    <div ontimeupdate="score()"></div>

    <!-- Area for the top scores tables -->
    <div id ="table"></div>

    <!-- Area to display the score. -->
    <div id="score"></div>

    <div id="end"></div>

    </body>

		<script>

/**
eval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--){d[e(c)]=k[c]||e(c)}k=[function(e){return d[e]}];e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}return p}('d m;d D=0;t A{q(h,i,j,b,c){8.h=h;8.c=c;8.b=b;8.i=i;8.j=j;8.l=0}Y(){8.j++}Z(){8.j--}1f(){8.i--;a(8.i<0)8.i=0}1g(){a(8.i+8.b>10-8.b)8.i=10-8.b;g 8.i++}H(L){o(d i=0;i<8.c.19;i++){d p=L[8.i+8.c[i][0]][8.j+8.c[i][1]];p.u=e;p.h=8.h;p.H()}}13(L){o(d i=0;i<8.c.19;i++){d p=L[8.i+8.c[i][0]][8.j+8.c[i][1]];p.u=e;p.h=8.h;p.f=e;p.H()}}Q(L){o(d i=0;i<8.c.19;i++){d 1q=8.i+8.c[i][0];d 17=8.j+8.c[i][1];a(17>=20)15 e;d p=L[1q][17];1c.1d(p);a(p.f)15 e}15 v}}t 1k I A{q(r){d c=[[0,0],[1,0],[2,0],[3,0]];d h=1X;E(h,3,0,4,c)}B(){8.l++;a(8.l%2==0){8.c=[[0,0],[1,0],[2,0],[3,0]];8.b=4;a(8.i+8.b>10-8.b)8.i=10-8.b}g{8.c=[[0,0],[0,1],[0,2],[0,3]];8.b=1}}}t 1l I A{q(r){d c=[[0,0],[1,0],[0,1],[1,1]];d h=22;E(h,4,0,2,c)}B(){}}t 1r I A{q(r){d c=[[1,0],[0,1],[1,1],[2,1]];d h=23;E(h,3,0,3,c)}B(){8.l++;a(8.l%4==0){8.c=[[1,0],[0,1],[1,1],[2,1]];8.b=3;a(8.i+8.b>10-8.b)8.i=10-8.b}g a(8.l%4==1){8.c=[[0,0],[0,1],[1,1],[0,2]];8.b=2}g a(8.l%4==2){8.c=[[0,0],[1,0],[2,0],[1,1]];8.b=3;a(8.i+8.b>10-8.b)8.i=10-8.b}g{8.c=[[1,0],[0,1],[1,1],[1,2]];8.b=2}}}t 1G I A{q(r){d c=[[1,0],[2,0],[0,1],[1,1]];d h=29;E(h,3,0,3,c)}B(){8.l++;a(8.l%2==0){8.c=[[1,0],[2,0],[0,1],[1,1]];8.b=3;a(8.i+8.b>10-8.b)8.i=10-8.b}g{8.c=[[0,0],[0,1],[1,1],[1,2]];8.b=2}}}t 1H I A{q(r){d c=[[0,0],[1,0],[1,1],[2,1]];d h=28;E(h,3,0,3,c)}B(){8.l++;a(8.l%2==0){8.c=[[0,0],[1,0],[1,1],[2,1]];8.b=3;a(8.i+8.b>10-8.b)8.i=10-8.b}g{8.c=[[1,0],[0,1],[1,1],[0,2]];8.b=2}}}t 1x I A{q(r){d c=[[0,0],[0,1],[1,1],[2,1]];d h=27;E(h,3,0,3,c)}B(){8.l++;a(8.l%4==0){8.c=[[0,0],[0,1],[1,1],[2,1]];8.b=3;a(8.i+8.b>10-8.b)8.i=10-8.b}g a(8.l%4==1){8.c=[[0,0],[1,0],[0,1],[0,2]];8.b=2}g a(8.l%4==2){8.c=[[0,0],[1,0],[2,0],[2,1]];8.b=3;a(8.i+8.b>10-8.b)8.i=10-8.b}g{8.c=[[1,0],[1,1],[0,2],[1,2]];8.b=2}}}t 1F I A{q(r){d c=[[2,0],[0,1],[1,1],[2,1]];d h=24;E(h,3,0,3,c)}B(){8.l++;a(8.l%4==0){8.c=[[2,0],[0,1],[1,1],[2,1]];8.b=3;a(8.i+8.b>10-8.b)8.i=10-8.b}g a(8.l%4==1){8.c=[[0,0],[0,1],[0,2],[1,2]];8.b=2}g a(8.l%4==2){8.c=[[0,0],[1,0],[2,0],[0,1]];8.b=3;a(8.i+8.b>10-8.b)8.i=10-8.b}g{8.c=[[0,0],[1,0],[1,1],[1,2]];8.b=2}}}t 1v{q(r,i,j){8.s=n O.1p();r.14(8.s);8.s.x=i*25;8.s.y=j*25;8.s.2a=N(){1c.1d("1U 1N")};8.f=v;8.h=1O}H(){8.s.1t();8.s.1w(8.h);8.s.1j(0,0,25,25);8.s.1h()}1P u(P){8.s.u=P}}t 1D{q(G){1c.1d("q o m");8.J=n O.1S();8.F=n O.1p();8.J.x=1o;8.J.y=1o;8.1u();8.J.14(8.F);8.1s(8.J);G.14(8.J);8.T();8.R();C.2b(\'2c\',8.1m.2p(8))8.1b=e}12(1n){D+=10;C.M("V").1a=D.X();C.M("18").P=D.X();o(d j=1n;j>=0;j--){o(d i=0;i<10;i++){a(j!=0){d 1e=8.9[i][j-1];a(1e.f){8.9[i][j].h=1e.h;8.9[i][j].u=e;8.9[i][j].f=e}g{8.9[i][j].u=v;8.9[i][j].f=v}}g{8.9[i][j].u=v;8.9[i][j].f=v}8.9[i][j].H()}}}1m(S){a(S.W=="2t"){8.k.Y();a(8.k.Q(8.9)){8.k.Z();8.k.13(8.9);o(d j=0;j<20;j++){d K=0;o(d i=0;i<10;i++){a(8.9[i][j].f==e)K++}a(K==10)8.12(j)}8.T();8.R()}}a(S.W=="2v"){8.k.1f();a(8.k.Q(8.9)){8.k.1g()}}a(S.W=="2u"){8.k.1g();a(8.k.Q(8.9)){8.k.1f()}}a(S.W=="2d"){8.k.B()}8.11();8.R()}R(){8.k.H(8.9)}1s(r){8.9=[];o(d i=0;i<10;i++){8.9[i]=[];o(d j=0;j<20;j++){8.9[i][j]=n 1v(r,i,j);8.9[i][j].u=v}}}11(){o(d i=0;i<10;i++){o(d j=0;j<20;j++){8.9[i][j].H();a(8.9[i][j].f){8.9[i][j].u=e}g{8.9[i][j].u=v}}}}1u(){8.F.1t();8.F.2l(2,2k);8.F.1w();8.F.1j(0,0,2j,1E);8.F.1h()}T(){d z=1i.2i((1i.z()*7)+1);a(z==1){a(8.9[3][0].f==e||8.9[4][0].f==e||8.9[5][0].f==e||8.9[6][0].f==e){8.w()}g{8.k=n 1k()}}g a(z==2)a(8.9[4][0].f==e||8.9[5][0].f==e||8.9[4][1].f==e||8.9[5][1].f==e){8.w()}g{8.k=n 1l()}g a(z==3)a(8.9[4][0].f==e||8.9[3][1].f==e||8.9[4][1].f==e||8.9[5][1].f==e){8.w()}g{8.k=n 1r()}g a(z==4)a(8.9[4][0].f==e||8.9[5][0].f==e||8.9[3][1].f==e||8.9[4][1].f==e){8.w()}g{8.k=n 1G()}g a(z==5)a(8.9[3][0].f==e||8.9[4][0].f==e||8.9[4][1].f==e||8.9[5][1].f==e){8.w()}g{8.k=n 1H()}g a(z==6)a(8.9[3][0].f==e||8.9[3][1].f==e||8.9[4][1].f==e||8.9[5][1].f==e){8.w()}g{8.k=n 1x()}g a(8.9[5][0].f==e||8.9[3][1].f==e||8.9[4][1].f==e||8.9[5][1].f==e){8.w()}g{8.k=n 1F()}}1B(){a(m.1b){m.k.Y();a(m.k.Q(m.9)){m.k.Z();m.k.13(m.9);o(d j=0;j<20;j++){d K=0;o(d i=0;i<10;i++){a(m.9[i][j].f==e)K++}a(K==10)m.12(j)}m.T()}m.11();m.R()}}w(){m.1b=v;C.M("18").P=D.X();C.M("2h").1a="2g 2n"}}d G;d U;d 1J=n 2e("2f.2m");N 2w(){$("1z").2r("2o")}N 16(){1C(16);U.2s(G)}N 2q(){G=n O.26();G.1K=e;U=O.1T(1E,1M,1L);C.1z.1Q(U.1R);1C(16);m=n 1D(G);1A.1y(m.1B,1V);1A.1y(1I,1W)}N 1I(){1J.1Y()}N V(){C.M("18").P=D}C.M("V").1a="1Z V 21: "+D.X();',62,157,'||||||||this|board_matrix|if|width|values|var|true|filled|else|color|||current_piece|rotationLevel|tetris|new|for|cell|constructor|container|square|class|visible|false|end_game|||random|Piece|rotate|document|globalScore|super|outline|stage|draw|extends|board|filledCells|matrix|getElementById|function|PIXI|value|conflict|draw_piece|key|select_random_piece|renderer|score|code|toString|down|up||clear_board|clear_row|fill|addChild|return|animate|j_offset|scoreValue|length|innerHTML|started|console|log|aboveCell|left|right|endFill|Math|drawRect|CyanI|YellowO|handle_key_presses|row|100|Graphics|i_offset|PurpleT|build_matrix|clear|draw_outline|Cell|beginFill|BlueJ|setInterval|body|window|drop_piece_down|requestAnimationFrame|Tetris|500|OrangeL|GreenS|RedZ|replay_song|bgmusic|interactive|null|750|over|0xffffff|set|appendChild|view|Sprite|autoDetectRenderer|mouse|1000|21000|0x00FFFF|play|Your||is|0xFFFF00|0x800080|0xFFA500||Container|0x0000FF|0xFF0000|0x00FF00|mouseover|addEventListener|keydown|ArrowUp|Audio|background|Game|end|floor|250|0xCCCCCC|lineStyle|mp3|Over|hello|bind|after_load|append|render|ArrowDown|ArrowRight|ArrowLeft|doit'.split('|'),0,{}))

*/

            var tetris;

            var globalScore = 0;

            /**
             * This class is the base class inherited by each tetris piece.
             */
            class Piece
            {

                /**
                 * Piece Constructor
                 *
                 * @param color: color of the piece
                 * @param i: starting column
                 * @param j: starting row
                 * @param width: width of the piece
                 * @param values: the placement of each cell in the piece
                 */
                constructor (color, i, j, width, values)
                {
                    this.color = color;
                    this.values = values;
                    this.width = width;

                    // Set position of piece
                    this.i = i;
                    this.j = j;
                    this.rotationLevel = 0;
                }

                /**
                 * Moves the piece down a row
                 */
                down ()
                {
                    this.j++;
                }

                up()
                {
                    this.j--;
                }

                /**
                 * Moves the piece on column to the left
                 */
                left()
                {
                    this.i--;
                    if (this.i < 0)
                            this.i = 0;
                }

                /**
                 * Moves the piece one column to the right.
                 */
                right()
                {
                    if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    else
                            this.i++;
                }

                /**
                 * This method changes the visibility of each cell in the piece and draws it on the matrix.
                 * @param matrix
                 */
                draw(matrix)
                {
                    for (var i = 0; i < this.values.length; i++)
                    {
                        var cell = matrix[this.i + this.values[i][0]][this.j + this.values[i][1]];
                        cell.visible = true;
                        cell.color = this.color;
                        cell.draw();
                    }
                }

                /**
                 * This method fills in the blocks once the piece hits the bottom of the matrix.
                 * @param matrix
                 */
                fill(matrix)
                {
                    for (var i = 0; i < this.values.length; i++)
                    {
                        var cell = matrix[this.i + this.values[i][0]][this.j + this.values[i][1]];
                        cell.visible = true;
                        cell.color = this.color;
                        cell.filled = true;
                        cell.draw()
                    }
                }

                /**
                 * This method returns true if the piece has hit another piece below it and false othewise.
                 * @param matrix
                 * @returns {boolean}
                 */
                conflict(matrix)
                {
                    for (var i = 0; i < this.values.length; i++)
                    {
                        var i_offset = this.i + this.values[i][0];
                        var j_offset = this.j + this.values[i][1];
                        if (j_offset >= 20) return true;
                        var cell = matrix[i_offset][j_offset];
                        console.log(cell);
                        if (cell.filled) return true
                    }
                    return false
                }
            }

            // Subclasses for game pieces
            /**
             * Each subclass for the pieces contains a contructor that calls the piece constructor and a
             * rotate method which recalulates the placement of the cells when the piece is rotated clockwise.
             */
            class CyanI extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [0,0],
                        [1,0],
                        [2,0],
                        [3,0]
                    ];

                    var color = 0x00FFFF;

                    //this.rotationLevel = 0;

                    super(color, 3, 0, 4, values);
                }

                rotate()
                {
                    this.rotationLevel++;

                    if (this.rotationLevel % 2 == 0)
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [2,0],
                            [3,0]
                        ];

                        this.width = 4;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else
                    {
                        this.values = [
                            [0,0],
                            [0,1],
                            [0,2],
                            [0,3]
                        ];

                        this.width = 1;
                    }
                }

            }

            class YellowO extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [0,0],
                        [1,0],
                        [0,1],
                        [1,1]
                    ];

                    var color = 0xFFFF00;

                    super(color, 4, 0, 2, values);
                }

                rotate(){}
            }

            class PurpleT extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [1,0],
                        [0,1],
                        [1,1],
                        [2,1]
                    ];

                    var color = 0x800080;

                    super(color, 3, 0, 3, values);
                }

                rotate()
                {
                    this.rotationLevel++;

                    if (this.rotationLevel % 4 == 0)
                    {
                        this.values = [
                            [1,0],
                            [0,1],
                            [1,1],
                            [2,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else if (this.rotationLevel % 4 == 1)
                    {
                        this.values = [
                            [0,0],
                            [0,1],
                            [1,1],
                            [0,2]
                        ];

                        this.width = 2;
                    }
                    else if (this.rotationLevel % 4 == 2)
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [2,0],
                            [1,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else
                    {
                        this.values = [
                            [1,0],
                            [0,1],
                            [1,1],
                            [1,2]
                        ];

                        this.width = 2;
                    }
                }
            }

            class GreenS extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [1,0],
                        [2,0],
                        [0,1],
                        [1,1]
                    ];

                    var color = 0x00FF00;

                    super(color, 3, 0, 3, values);
                }

                rotate()
                {
                    this.rotationLevel++;

                    if (this.rotationLevel % 2 == 0)
                    {
                        this.values = [
                            [1,0],
                            [2,0],
                            [0,1],
                            [1,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else
                    {
                        this.values = [
                            [0,0],
                            [0,1],
                            [1,1],
                            [1,2]
                        ];

                        this.width = 2;
                    }
                }
            }

            class RedZ extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [0,0],
                        [1,0],
                        [1,1],
                        [2,1]
                    ];

                    var color = 0xFF0000;

                    super(color, 3, 0, 3, values);
                }

                rotate()
                {
                    this.rotationLevel++;

                    if (this.rotationLevel % 2 == 0)
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [1,1],
                            [2,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else
                    {
                        this.values = [
                            [1,0],
                            [0,1],
                            [1,1],
                            [0,2]
                        ];

                        this.width = 2;
                    }
                }
            }

            class BlueJ extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [0,0],
                        [0,1],
                        [1,1],
                        [2,1]
                    ];

                    var color = 0x0000FF;

                    super(color, 3, 0, 3, values);
                }

                rotate()
                {
                    this.rotationLevel++;

                    if (this.rotationLevel % 4 == 0)
                    {
                        this.values = [
                            [0,0],
                            [0,1],
                            [1,1],
                            [2,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else if (this.rotationLevel % 4 == 1)
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [0,1],
                            [0,2]
                        ];

                        this.width = 2;
                    }
                    else if (this.rotationLevel % 4 == 2)
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [2,0],
                            [2,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else
                    {
                        this.values = [
                            [1,0],
                            [1,1],
                            [0,2],
                            [1,2]
                        ];

                        this.width = 2;
                    }
                }
            }

            class OrangeL extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [2,0],
                        [0,1],
                        [1,1],
                        [2,1]
                    ];

                    var color = 0xFFA500;

                    super(color, 3, 0, 3, values);
                }

                rotate()
                {
                    this.rotationLevel++;

                    if (this.rotationLevel % 4 == 0)
                    {
                        this.values = [
                            [2,0],
                            [0,1],
                            [1,1],
                            [2,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else if (this.rotationLevel % 4 == 1)
                    {
                        this.values = [
                            [0,0],
                            [0,1],
                            [0,2],
                            [1,2]
                        ];

                        this.width =2;
                    }
                    else if (this.rotationLevel % 4 == 2)
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [2,0],
                            [0,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [1,1],
                            [1,2]
                        ];

                        this.width = 2;
                    }
                }
            }

            /**
             * This class creates the individual blocks used go make a tetris piece.
             */
            class Cell
            {
                /**
                 * The constructor for the cell class takes in a container and an x and y coordinate of
                 * where the cell is loacated on the game matrix.
                 */
                constructor(container, i, j)
                {
                    this.square = new PIXI.Graphics();
                    container.addChild(this.square);
                    this.square.x = i * 25;
                    this.square.y = j * 25;

                    this.square.mouseover = function() {
                        console.log("mouse over")
                    };

                    this.filled = false;
                    this.color = 0xffffff
                }

                /**
                 * This method draws the cell on the gameboard.
                 */
                draw()
                {
                    this.square.clear();
                    this.square.beginFill(this.color);
                    this.square.drawRect(0, 0, 25, 25);
                    this.square.endFill()
                }

                /**
                 * This method sets the visibility.
                 * @param value
                 */
                set visible(value)
                {
                    this.square.visible = value
                }
            }

            /**
             * This class creates the tetris gameboards and runs the gameplay.
             */
            class Tetris
            {

                /**
                 * The tetris constructor sets up the game matrix and begins gameplay.
                 * @param stage
                 */
                constructor(stage)
                {
                    console.log("constructor for tetris");
                    this.board = new PIXI.Sprite();
                    this.outline = new PIXI.Graphics();
                    this.board.x = 100;
                    this.board.y = 100;
                    this.draw_outline();
                    this.board.addChild(this.outline);
                    this.build_matrix(this.board);
                    stage.addChild(this.board);

                    // Randomly generate a piece
                    this.select_random_piece();

                    this.draw_piece();
                    document.addEventListener('keydown', this.handle_key_presses.bind(this))
                    this.started = true;
                }

                /**
                 * This method is called when a row is full and needs to be cleared.
                 * @param row
                 */
                clear_row(row)
                {
                    // Add 10 to the score and place this value in the score and scoreValue ids.
                    globalScore += 10;

                    document.getElementById("score").innerHTML = globalScore.toString();

                    document.getElementById("scoreValue").value = globalScore.toString();

                    for (var j = row; j >= 0; j--)
                    {
                        for (var i = 0; i < 10; i++)
                        {
                            //If you are not looking at the first row
                            if (j != 0)
                            {
                                var aboveCell = this.board_matrix[i][j - 1]; // The cell above cell i,j
                                // If the cell abobe the current cell is filled...
                                if (aboveCell.filled)
                                {
                                    // Change the current cell's color to the color of the cell above it and change
                                    // The visibility and filled properties to true.
                                    this.board_matrix[i][j].color = aboveCell.color;
                                    this.board_matrix[i][j].visible = true;
                                    this.board_matrix[i][j].filled = true;
                                }
                                // If the cell above the current cell is not filled change visible and filled properties to false.
                                else
                                {
                                    this.board_matrix[i][j].visible = false;
                                    this.board_matrix[i][j].filled = false;
                                }
                            }
                            // Change visible and filled properties of cells in the top row to false.
                            else
                            {
                                this.board_matrix[i][j].visible = false;
                                this.board_matrix[i][j].filled = false;
                            }

                            // Draw the new cell with its new properties.
                            this.board_matrix[i][j].draw();
                        }
                    }
                }

                // This method is called when a key is pressed.
                handle_key_presses(key)
                {
                    // When the down arrow is pressed...
                    if (key.code == "ArrowDown")
                    {
                        // Move the piece on row down the matrix
                        this.current_piece.down();

                        // if there is a conflict...
                        if (this.current_piece.conflict(this.board_matrix))
                        {
                            // Move the piece back up a row and fill the piece.
                            this.current_piece.up();
                            this.current_piece.fill(this.board_matrix);

                            // Check for any full rows and call clear_row if there is a full row.
                            for (var j = 0; j < 20; j++)
                            {
                                var filledCells = 0;

                                for (var i = 0; i < 10; i++)
                                {
                                    if (this.board_matrix[i][j].filled == true)
                                            filledCells++;
                                }

                                if (filledCells == 10)
                                        this.clear_row(j);

                            }

                            // Randomly generate a new piece and draw it on the matrix
                            this.select_random_piece();
                            this.draw_piece()
                        }
                    }

                    // If the left arrow is pressed, move the piece to the left and check for a conflict.
                    if (key.code == "ArrowLeft")
                    {
                        this.current_piece.left();
                        if (this.current_piece.conflict(this.board_matrix))
                        {
                            this.current_piece.right()
                        }
                    }

                    // If the right arrow is pressed, move the piece to the right and check for a conflict.
                    if (key.code == "ArrowRight")
                    {
                        this.current_piece.right();
                        if (this.current_piece.conflict(this.board_matrix))
                        {
                            this.current_piece.left()
                        }
                    }

                    // If the right arrow is pressed rotate the piece.
                    if (key.code == "ArrowUp")
                    {
                        this.current_piece.rotate();
                    }

                    // Clear the board of not visible pieces and draw the new piece.
                    this.clear_board();
                    this.draw_piece()
                }

                /**
                 * This method draws the current piece on the board.
                 */
                draw_piece()
                {
                    this.current_piece.draw(this.board_matrix);
                }

                /**
                 * This method creates a new game matrix made up of 20 rows and 10 columns of cells
                 * @param container
                 */
                build_matrix(container)
                {
                    this.board_matrix = [];
                    for (var i = 0; i < 10; i++)
                    {
                        this.board_matrix[i] = [];
                        for (var j = 0; j < 20; j++)
                        {
                            this.board_matrix[i][j] = new Cell(container, i, j);
                            this.board_matrix[i][j].visible = false
                        }
                    }
                }

                /**
                 * This method changes the visibility for filled and not filled cells.
                 */
                clear_board()
                {
                    for (var i = 0; i < 10; i++)
                    {
                        for (var j = 0; j < 20; j++)
                        {
                            this.board_matrix[i][j].draw();
                            if (this.board_matrix[i][j].filled)
                            {
                                this.board_matrix[i][j].visible = true
                            }
                            else
                            {
                                this.board_matrix[i][j].visible = false
                            }
                        }
                    }
                }

                /**
                 * This method draws the white boardero on the game matrix.
                 */
                draw_outline()
                {
                    this.outline.clear();
                    this.outline.lineStyle(2, 0xCCCCCC);
                    this.outline.beginFill();
                    this.outline.drawRect(0, 0, 250, 500);
                    this.outline.endFill()
                }


                /**
                 * This method generates a random pieced based on a random number generator.  If there is not enough room for the piece to
                 * spawn at the top of the board, the end_game method is called.
                 */
                select_random_piece()
                {
                    var random = Math.floor((Math.random() * 7) + 1);

                    if (random == 1)
                    {
                        if (this.board_matrix[3][0].filled == true || this.board_matrix[4][0].filled == true || this.board_matrix[5][0].filled == true
                            || this.board_matrix[6][0].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new CyanI();

                        }
                    }
                     else if (random == 2)
                        if (this.board_matrix[4][0].filled == true || this.board_matrix[5][0].filled == true || this.board_matrix[4][1].filled == true
                                || this.board_matrix[5][1].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new YellowO();

                        }
                     else if (random == 3)
                        if (this.board_matrix[4][0].filled == true || this.board_matrix[3][1].filled == true || this.board_matrix[4][1].filled == true
                                || this.board_matrix[5][1].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new PurpleT();
                        }
                     else if (random == 4)
                        if (this.board_matrix[4][0].filled == true || this.board_matrix[5][0].filled == true || this.board_matrix[3][1].filled == true
                                || this.board_matrix[4][1].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new GreenS();
                        }
                     else if (random == 5)
                        if (this.board_matrix[3][0].filled == true || this.board_matrix[4][0].filled == true || this.board_matrix[4][1].filled == true
                                || this.board_matrix[5][1].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new RedZ();
                        }
                     else if (random == 6)
                        if (this.board_matrix[3][0].filled == true || this.board_matrix[3][1].filled == true || this.board_matrix[4][1].filled == true
                                || this.board_matrix[5][1].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new BlueJ();
                        }
                     else
                        if (this.board_matrix[5][0].filled == true || this.board_matrix[3][1].filled == true || this.board_matrix[4][1].filled == true
                                || this.board_matrix[5][1].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new OrangeL();
                        }
                }

                /**
                 * This method is called to continuously drop the piece down even if the down button is not pressed/
                 */
                drop_piece_down() {
                    if (tetris.started) {
                        tetris.current_piece.down();
                        if (tetris.current_piece.conflict(tetris.board_matrix)) {
                            tetris.current_piece.up();
                            tetris.current_piece.fill(tetris.board_matrix);

                            // Remove full rows and bring everything down
                            for (var j = 0; j < 20; j++) {
                                var filledCells = 0;

                                for (var i = 0; i < 10; i++) {
                                    if (tetris.board_matrix[i][j].filled == true)
                                        filledCells++;
                                }

                                if (filledCells == 10)
                                    tetris.clear_row(j);
                            }

                            // Randomly generate a piece
                            tetris.select_random_piece();

                        }
                        tetris.clear_board();
                        tetris.draw_piece();
                    }
                }

                /**
                 * When the game ends, change the state of the game, update the scoreValue id objectt and print out
                 * "Game Over".
                 */
                end_game()
                {
                    tetris.started = false;
                    document.getElementById("scoreValue").value = globalScore.toString();
                    document.getElementById("end").innerHTML="Game Over";
                }
            }

            var stage;
            var renderer;
            var bgmusic = new Audio("background.mp3");

            function doit()
            {
                $("body").append("hello")
            }

            function animate()
            {
                requestAnimationFrame(animate);
                renderer.render(stage)
            }

            function after_load() {
                stage = new PIXI.Container();
                stage.interactive = true;
                renderer = PIXI.autoDetectRenderer(500, 750, null);
                document.body.appendChild(renderer.view);
                requestAnimationFrame(animate);
                tetris = new Tetris(stage);
                window.setInterval(tetris.drop_piece_down, 1000);
                window.setInterval(replay_song, 21000);

            }

            /**
             * This method replays the background music once it ends.
             */
            function replay_song()
            {
                bgmusic.play();
            }

            /**
             * this method sets the value of the scoreValue element.
             */
            function score()
            {
                document.getElementById("scoreValue").value = globalScore;
            }

            // Prings out the score inside the score element.
            document.getElementById("score").innerHTML="Your score is: " + globalScore.toString();

        </script>

</html>
