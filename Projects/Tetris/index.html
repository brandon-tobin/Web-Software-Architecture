<!DOCTYPE html>
<html lang="en">
    <head>
        <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
        <meta content="utf-8" http-equiv="encoding">
        <title>Tetris</title>

        <!-- THIS FIRST -->
        <link rel="stylesheet" href="../../Resources/css/stylesheet.css" type="text/css"/>


        <script src="jquery-1.11.2.min.js"></script>
        <script src="pixi.js"></script>
        <script type="text/javascript" src="//code.jquery.com/jquery-1.9.1.js"></script>
        <script type="text/javascript" src="get_data.js"></script>


    </head>
    <body id="body">

    <div id="header">
        <img src="/Resources/Images/uofufootball.jpg" alt="Rice Eccles Stadium" />
        <h1>University of Utah - CS 4540</h1>
        <h2>Web Software Architecture - Spring 2016</h2>
        <h2>Brandon Tobin</h2>
        <h2>Projects</h2>
    </div>

    <!-- Navigation Bar -->
    <ul id="navigation">
        <li><a href="../.../index.html">Home</a></li>
        <li><a href="../index.html">Projects</a></li>
        <li><a href="../Class_Examples/">Examples</a></li>
        <li><a href="../Projects/V3/schema.html">Database Schema</a></li>
    </ul>

    <br /><br />

    <!-- Start Button -->
    <input type="button" class="button" id="start" value="Start Game" onclick="after_load()" />

    <br />

    <!-- Area for AJAx-->
    <div id="pagetop">
        <form method='post' id = "nameSubmit">
            <label for="name">Name:</label>
            <input type="text" name="name" id="name" onkeyup="score()" />
            <input type="button" class="button" name='submit' value='Submit Score' onclick="find_data()"/>
            <input type = "hidden" name="scoreValue" id = "scoreValue" value="" />
        </form>
    </div>

    <!-- Calls the score() method when the time updates -->
    <div ontimeupdate="score()"></div>

    <!-- Area for the top scores tables -->
    <div id ="table"></div>

    <!-- Area to display the score. -->
    <div id="score"></div>

    <div id="end"></div>

    </body>

        <script>

            var tetris;

            var globalScore = 0;

            /**
             * This class is the base class inherited by each tetris piece.
             */
            class Piece
            {

                /**
                 * Piece Constructor
                 *
                 * @param color: color of the piece
                 * @param i: starting column
                 * @param j: starting row
                 * @param width: width of the piece
                 * @param values: the placement of each cell in the piece
                 */
                constructor (color, i, j, width, values)
                {
                    this.color = color;
                    this.values = values;
                    this.width = width;

                    // Set position of piece
                    this.i = i;
                    this.j = j;
                    this.rotationLevel = 0;
                }

                /**
                 * Moves the piece down a row
                 */
                down ()
                {
                    this.j++;
                }

                up()
                {
                    this.j--;
                }

                /**
                 * Moves the piece on column to the left
                 */
                left()
                {
                    this.i--;
                    if (this.i < 0)
                            this.i = 0;
                }

                /**
                 * Moves the piece one column to the right.
                 */
                right()
                {
                    if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    else
                            this.i++;
                }

                /**
                 * This method changes the visibility of each cell in the piece and draws it on the matrix.
                 * @param matrix
                 */
                draw(matrix)
                {
                    for (var i = 0; i < this.values.length; i++)
                    {
                        var cell = matrix[this.i + this.values[i][0]][this.j + this.values[i][1]];
                        cell.visible = true;
                        cell.color = this.color;
                        cell.draw();
                    }
                }

                /**
                 * This method fills in the blocks once the piece hits the bottom of the matrix.
                 * @param matrix
                 */
                fill(matrix)
                {
                    for (var i = 0; i < this.values.length; i++)
                    {
                        var cell = matrix[this.i + this.values[i][0]][this.j + this.values[i][1]];
                        cell.visible = true;
                        cell.color = this.color;
                        cell.filled = true;
                        cell.draw()
                    }
                }

                /**
                 * This method returns true if the piece has hit another piece below it and false othewise.
                 * @param matrix
                 * @returns {boolean}
                 */
                conflict(matrix)
                {
                    for (var i = 0; i < this.values.length; i++)
                    {
                        var i_offset = this.i + this.values[i][0];
                        var j_offset = this.j + this.values[i][1];
                        if (j_offset >= 20) return true;
                        var cell = matrix[i_offset][j_offset];
                        console.log(cell);
                        if (cell.filled) return true
                    }
                    return false
                }
            }

            // Subclasses for game pieces
            /**
             * Each subclass for the pieces contains a contructor that calls the piece constructor and a
             * rotate method which recalulates the placement of the cells when the piece is rotated clockwise.
             */
            class CyanI extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [0,0],
                        [1,0],
                        [2,0],
                        [3,0]
                    ];

                    var color = 0x00FFFF;

                    //this.rotationLevel = 0;

                    super(color, 3, 0, 4, values);
                }

                rotate()
                {
                    this.rotationLevel++;

                    if (this.rotationLevel % 2 == 0)
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [2,0],
                            [3,0]
                        ];

                        this.width = 4;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else
                    {
                        this.values = [
                            [0,0],
                            [0,1],
                            [0,2],
                            [0,3]
                        ];

                        this.width = 1;
                    }
                }

            }

            class YellowO extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [0,0],
                        [1,0],
                        [0,1],
                        [1,1]
                    ];

                    var color = 0xFFFF00;

                    super(color, 4, 0, 2, values);
                }

                rotate(){}
            }

            class PurpleT extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [1,0],
                        [0,1],
                        [1,1],
                        [2,1]
                    ];

                    var color = 0x800080;

                    super(color, 3, 0, 3, values);
                }

                rotate()
                {
                    this.rotationLevel++;

                    if (this.rotationLevel % 4 == 0)
                    {
                        this.values = [
                            [1,0],
                            [0,1],
                            [1,1],
                            [2,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else if (this.rotationLevel % 4 == 1)
                    {
                        this.values = [
                            [0,0],
                            [0,1],
                            [1,1],
                            [0,2]
                        ];

                        this.width = 2;
                    }
                    else if (this.rotationLevel % 4 == 2)
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [2,0],
                            [1,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else
                    {
                        this.values = [
                            [1,0],
                            [0,1],
                            [1,1],
                            [1,2]
                        ];

                        this.width = 2;
                    }
                }
            }

            class GreenS extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [1,0],
                        [2,0],
                        [0,1],
                        [1,1]
                    ];

                    var color = 0x00FF00;

                    super(color, 3, 0, 3, values);
                }

                rotate()
                {
                    this.rotationLevel++;

                    if (this.rotationLevel % 2 == 0)
                    {
                        this.values = [
                            [1,0],
                            [2,0],
                            [0,1],
                            [1,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else
                    {
                        this.values = [
                            [0,0],
                            [0,1],
                            [1,1],
                            [1,2]
                        ];

                        this.width = 2;
                    }
                }
            }

            class RedZ extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [0,0],
                        [1,0],
                        [1,1],
                        [2,1]
                    ];

                    var color = 0xFF0000;

                    super(color, 3, 0, 3, values);
                }

                rotate()
                {
                    this.rotationLevel++;

                    if (this.rotationLevel % 2 == 0)
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [1,1],
                            [2,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else
                    {
                        this.values = [
                            [1,0],
                            [0,1],
                            [1,1],
                            [0,2]
                        ];

                        this.width = 2;
                    }
                }
            }

            class BlueJ extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [0,0],
                        [0,1],
                        [1,1],
                        [2,1]
                    ];

                    var color = 0x0000FF;

                    super(color, 3, 0, 3, values);
                }

                rotate()
                {
                    this.rotationLevel++;

                    if (this.rotationLevel % 4 == 0)
                    {
                        this.values = [
                            [0,0],
                            [0,1],
                            [1,1],
                            [2,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else if (this.rotationLevel % 4 == 1)
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [0,1],
                            [0,2]
                        ];

                        this.width = 2;
                    }
                    else if (this.rotationLevel % 4 == 2)
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [2,0],
                            [2,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else
                    {
                        this.values = [
                            [1,0],
                            [1,1],
                            [0,2],
                            [1,2]
                        ];

                        this.width = 2;
                    }
                }
            }

            class OrangeL extends Piece
            {
                constructor(container)
                {
                    var values = [
                        [2,0],
                        [0,1],
                        [1,1],
                        [2,1]
                    ];

                    var color = 0xFFA500;

                    super(color, 3, 0, 3, values);
                }

                rotate()
                {
                    this.rotationLevel++;

                    if (this.rotationLevel % 4 == 0)
                    {
                        this.values = [
                            [2,0],
                            [0,1],
                            [1,1],
                            [2,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else if (this.rotationLevel % 4 == 1)
                    {
                        this.values = [
                            [0,0],
                            [0,1],
                            [0,2],
                            [1,2]
                        ];

                        this.width =2;
                    }
                    else if (this.rotationLevel % 4 == 2)
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [2,0],
                            [0,1]
                        ];

                        this.width = 3;

                        if (this.i + this.width > 10 - this.width)
                            this.i = 10 - this.width;
                    }
                    else
                    {
                        this.values = [
                            [0,0],
                            [1,0],
                            [1,1],
                            [1,2]
                        ];

                        this.width = 2;
                    }
                }
            }

            /**
             * This class creates the individual blocks used go make a tetris piece.
             */
            class Cell
            {
                /**
                 * The constructor for the cell class takes in a container and an x and y coordinate of
                 * where the cell is loacated on the game matrix.
                 */
                constructor(container, i, j)
                {
                    this.square = new PIXI.Graphics();
                    container.addChild(this.square);
                    this.square.x = i * 25;
                    this.square.y = j * 25;

                    this.square.mouseover = function() {
                        console.log("mouse over")
                    };

                    this.filled = false;
                    this.color = 0xffffff
                }

                /**
                 * This method draws the cell on the gameboard.
                 */
                draw()
                {
                    this.square.clear();
                    this.square.beginFill(this.color);
                    this.square.drawRect(0, 0, 25, 25);
                    this.square.endFill()
                }

                /**
                 * This method sets the visibility.
                 * @param value
                 */
                set visible(value)
                {
                    this.square.visible = value
                }
            }

            /**
             * This class creates the tetris gameboards and runs the gameplay.
             */
            class Tetris
            {

                /**
                 * The tetris constructor sets up the game matrix and begins gameplay.
                 * @param stage
                 */
                constructor(stage)
                {
                    console.log("constructor for tetris");
                    this.board = new PIXI.Sprite();
                    this.outline = new PIXI.Graphics();
                    this.board.x = 100;
                    this.board.y = 100;
                    this.draw_outline();
                    this.board.addChild(this.outline);
                    this.build_matrix(this.board);
                    stage.addChild(this.board);

                    // Randomly generate a piece
                    this.select_random_piece();

                    this.draw_piece();
                    document.addEventListener('keydown', this.handle_key_presses.bind(this))
                    this.started = true;
                }

                /**
                 * This method is called when a row is full and needs to be cleared.
                 * @param row
                 */
                clear_row(row)
                {
                    // Add 10 to the score and place this value in the score and scoreValue ids.
                    globalScore += 10;

                    document.getElementById("score").innerHTML = globalScore.toString();

                    document.getElementById("scoreValue").value = globalScore.toString();

                    for (var j = row; j >= 0; j--)
                    {
                        for (var i = 0; i < 10; i++)
                        {
                            //If you are not looking at the first row
                            if (j != 0)
                            {
                                var aboveCell = this.board_matrix[i][j - 1]; // The cell above cell i,j
                                // If the cell abobe the current cell is filled...
                                if (aboveCell.filled)
                                {
                                    // Change the current cell's color to the color of the cell above it and change
                                    // The visibility and filled properties to true.
                                    this.board_matrix[i][j].color = aboveCell.color;
                                    this.board_matrix[i][j].visible = true;
                                    this.board_matrix[i][j].filled = true;
                                }
                                // If the cell above the current cell is not filled change visible and filled properties to false.
                                else
                                {
                                    this.board_matrix[i][j].visible = false;
                                    this.board_matrix[i][j].filled = false;
                                }
                            }
                            // Change visible and filled properties of cells in the top row to false.
                            else
                            {
                                this.board_matrix[i][j].visible = false;
                                this.board_matrix[i][j].filled = false;
                            }

                            // Draw the new cell with its new properties.
                            this.board_matrix[i][j].draw();
                        }
                    }
                }

                // This method is called when a key is pressed.
                handle_key_presses(key)
                {
                    // When the down arrow is pressed...
                    if (key.code == "ArrowDown")
                    {
                        // Move the piece on row down the matrix
                        this.current_piece.down();

                        // if there is a conflict...
                        if (this.current_piece.conflict(this.board_matrix))
                        {
                            // Move the piece back up a row and fill the piece.
                            this.current_piece.up();
                            this.current_piece.fill(this.board_matrix);

                            // Check for any full rows and call clear_row if there is a full row.
                            for (var j = 0; j < 20; j++)
                            {
                                var filledCells = 0;

                                for (var i = 0; i < 10; i++)
                                {
                                    if (this.board_matrix[i][j].filled == true)
                                            filledCells++;
                                }

                                if (filledCells == 10)
                                        this.clear_row(j);

                            }

                            // Randomly generate a new piece and draw it on the matrix
                            this.select_random_piece();
                            this.draw_piece()
                        }
                    }

                    // If the left arrow is pressed, move the piece to the left and check for a conflict.
                    if (key.code == "ArrowLeft")
                    {
                        this.current_piece.left();
                        if (this.current_piece.conflict(this.board_matrix))
                        {
                            this.current_piece.right()
                        }
                    }

                    // If the right arrow is pressed, move the piece to the right and check for a conflict.
                    if (key.code == "ArrowRight")
                    {
                        this.current_piece.right();
                        if (this.current_piece.conflict(this.board_matrix))
                        {
                            this.current_piece.left()
                        }
                    }

                    // If the right arrow is pressed rotate the piece.
                    if (key.code == "ArrowUp")
                    {
                        this.current_piece.rotate();
                    }

                    // Clear the board of not visible pieces and draw the new piece.
                    this.clear_board();
                    this.draw_piece()
                }

                /**
                 * This method draws the current piece on the board.
                 */
                draw_piece()
                {
                    this.current_piece.draw(this.board_matrix);
                }

                /**
                 * This method creates a new game matrix made up of 20 rows and 10 columns of cells
                 * @param container
                 */
                build_matrix(container)
                {
                    this.board_matrix = [];
                    for (var i = 0; i < 10; i++)
                    {
                        this.board_matrix[i] = [];
                        for (var j = 0; j < 20; j++)
                        {
                            this.board_matrix[i][j] = new Cell(container, i, j);
                            this.board_matrix[i][j].visible = false
                        }
                    }
                }

                /**
                 * This method changes the visibility for filled and not filled cells.
                 */
                clear_board()
                {
                    for (var i = 0; i < 10; i++)
                    {
                        for (var j = 0; j < 20; j++)
                        {
                            this.board_matrix[i][j].draw();
                            if (this.board_matrix[i][j].filled)
                            {
                                this.board_matrix[i][j].visible = true
                            }
                            else
                            {
                                this.board_matrix[i][j].visible = false
                            }
                        }
                    }
                }

                /**
                 * This method draws the white boardero on the game matrix.
                 */
                draw_outline()
                {
                    this.outline.clear();
                    this.outline.lineStyle(2, 0xCCCCCC);
                    this.outline.beginFill();
                    this.outline.drawRect(0, 0, 250, 500);
                    this.outline.endFill()
                }


                /**
                 * This method generates a random pieced based on a random number generator.  If there is not enough room for the piece to
                 * spawn at the top of the board, the end_game method is called.
                 */
                select_random_piece()
                {
                    var random = Math.floor((Math.random() * 7) + 1);

                    if (random == 1)
                    {
                        if (this.board_matrix[3][0].filled == true || this.board_matrix[4][0].filled == true || this.board_matrix[5][0].filled == true
                            || this.board_matrix[6][0].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new CyanI();

                        }
                    }
                     else if (random == 2)
                        if (this.board_matrix[4][0].filled == true || this.board_matrix[5][0].filled == true || this.board_matrix[4][1].filled == true
                                || this.board_matrix[5][1].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new YellowO();

                        }
                     else if (random == 3)
                        if (this.board_matrix[4][0].filled == true || this.board_matrix[3][1].filled == true || this.board_matrix[4][1].filled == true
                                || this.board_matrix[5][1].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new PurpleT();
                        }
                     else if (random == 4)
                        if (this.board_matrix[4][0].filled == true || this.board_matrix[5][0].filled == true || this.board_matrix[3][1].filled == true
                                || this.board_matrix[4][1].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new GreenS();
                        }
                     else if (random == 5)
                        if (this.board_matrix[3][0].filled == true || this.board_matrix[4][0].filled == true || this.board_matrix[4][1].filled == true
                                || this.board_matrix[5][1].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new RedZ();
                        }
                     else if (random == 6)
                        if (this.board_matrix[3][0].filled == true || this.board_matrix[3][1].filled == true || this.board_matrix[4][1].filled == true
                                || this.board_matrix[5][1].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new BlueJ();
                        }
                     else
                        if (this.board_matrix[5][0].filled == true || this.board_matrix[3][1].filled == true || this.board_matrix[4][1].filled == true
                                || this.board_matrix[5][1].filled == true)
                        {
                            this.end_game();
                        }
                        else
                        {
                            this.current_piece = new OrangeL();
                        }
                }

                /**
                 * This method is called to continuously drop the piece down even if the down button is not pressed/
                 */
                drop_piece_down() {
                    if (tetris.started) {
                        tetris.current_piece.down();
                        if (tetris.current_piece.conflict(tetris.board_matrix)) {
                            tetris.current_piece.up();
                            tetris.current_piece.fill(tetris.board_matrix);

                            // Remove full rows and bring everything down
                            for (var j = 0; j < 20; j++) {
                                var filledCells = 0;

                                for (var i = 0; i < 10; i++) {
                                    if (tetris.board_matrix[i][j].filled == true)
                                        filledCells++;
                                }

                                if (filledCells == 10)
                                    tetris.clear_row(j);
                            }

                            // Randomly generate a piece
                            tetris.select_random_piece();

                        }
                        tetris.clear_board();
                        tetris.draw_piece();
                    }
                }

                /**
                 * When the game ends, change the state of the game, update the scoreValue id objectt and print out
                 * "Game Over".
                 */
                end_game()
                {
                    tetris.started = false;
                    document.getElementById("scoreValue").value = globalScore.toString();
                    document.getElementById("end").innerHTML="Game Over";
                }
            }

            var stage;
            var renderer;
            var bgmusic = new Audio("background.mp3");

            function doit()
            {
                $("body").append("hello")
            }

            function animate()
            {
                requestAnimationFrame(animate);
                renderer.render(stage)
            }

            function after_load() {
                stage = new PIXI.Container();
                stage.interactive = true;
                renderer = PIXI.autoDetectRenderer(500, 750, null);
                document.body.appendChild(renderer.view);
                requestAnimationFrame(animate);
                tetris = new Tetris(stage);
                window.setInterval(tetris.drop_piece_down, 1000);
                window.setInterval(replay_song, 21000);

            }

            /**
             * This method replays the background music once it ends.
             */
            function replay_song()
            {
                bgmusic.play();
            }

            /**
             * this method sets the value of the scoreValue element.
             */
            function score()
            {
                document.getElementById("scoreValue").value = globalScore;
            }

            // Prings out the score inside the score element.
            document.getElementById("score").innerHTML="Your score is: " + globalScore.toString();

        </script>

</html>